# Тестовое задание для отбора на Летнюю ИТ-школу КРОК по разработке

## Условие задания
Один развивающийся и перспективный маркетплейс активно растет в настоящее время. Текущая команда разработки вовсю занята тем, что развивает ядро системы. Помимо этого, перед CTO маркетплейса стоит задача — разработать подсистему аналитики, которая на основе накопленных данных формировала бы разнообразные отчеты и статистику.

Вы — компания подрядчик, с которой маркетплейс заключил рамочный договор на выполнение работ по разработке этой подсистемы. В рамках первого этапа вы условились провести работы по прототипированию и определению целевого технологического стека и общих подходов к разработке.

На одном из совещаний с Заказчиком вы определили задачу, на которой будете выполнять работы по прототипированию. В качестве такой задачи была выбрана разработка отчета о периодах наибольших трат со стороны пользователей.

Аналитики со стороны маркетплейса предоставили небольшой срез массива данных (файл format.json) о покупках пользователей, на примере которого вы смогли бы ознакомиться с форматом входных данных. Каждая запись данного среза содержит следующую информацию:
- Идентификатор пользователя;
- Дата и время оформления заказа;
- Статус заказа;
- Сумма заказа.

В пояснительной записке к массиву данных была уточняющая информация относительно статусов заказов:
- COMPLETED (Завершенный заказ);
- CANCELED (Отмененный заказ);
- CREATED (Созданный заказ, еще не оплаченный);
- DELIVERY (Созданный и оплаченный заказ, который доставляется).

Необходимо разработать отчет, вычисляющий по полученному массиву данных месяц, когда пользователи тратили больше всего. Если максимальная сумма пользовательских трат была в более, чем одном месяце, отчет должен показывать все такие месяцы. В отчете должны учитываться только завершенные заказы.

Требования к реализации:
1. Реализация должна содержать, как минимум, одну процедуру (функцию/метод), отвечающую за формирование отчета, и должна быть описана в readme.md в соответствии с чек-листом;
2. В качестве входных данных программа использует json-файл (input.json), соответствующий структуре, описанной в условиях задания;
3. Процедура (функция/метод) формирования отчета должна возвращать строку в формате json следующего формата:
   - {«months»: [«march»]} 
   - {«months»: [«march», «december»]}
4. Найденный в соответствии с условием задачи месяц должен выводиться на английском языке в нижнем регистре. Если месяцев несколько, то на вывод они все подаются на английском языке в нижнем регистре в порядке их следования в течение года.

## Автор решения
Чекалов Павел Владиславович

## Описание реализации
Функциональные единицы:
1. Ввод.

   ```
   std::stringstream input_from_file(std::string input_filename)
   ```
   Принимает имя файла и возвращает строку-поток. Строка-поток - это наиболее универсальный формат для передачи данных внутри программы.
2. Десериализация (парсинг файла в т.ч.).

   ```
   std::vector<Transaction> transactions_from_json(std::stringstream& input)
   ```
   Принимает строку-поток и возвращает вектор (STL) структур ```Tranaction```. В рамках данной функции происходит парсинг входных данных (источник не важен, но должны соответствовать указанному формату JSON). Используется вспомогательная функция ```std::string scan_json_struct(std::stringstream& input, char start_char)``` для корректного деления файла на структуры.
3. Анализ данных.

    ```
    std::vector<std::string> months_with_max_completed_sum_total(std::vector<Transaction>& transactions)
    ```
    Принимает вектор одних структур, возвращает вектор других. В нашем случае, принимает набор ```Tranaction``` и возвращает набор строк.
4. Сериализация.

   ```
   std::stringstream months_to_json(std::vector<std::string>& months)
   ```
   Принимает вектор строк, возвращает строку-поток, соответствующую JSON-формату.
5. Вывод.

   Для консольного вывода отдельная функция не нужна - строку-поток достаточно превратить в строку и вывести в стандартный поток.

   Для файлового вывода:
   ```
   void output_to_file(std::string output_filename,std::stringstream& output)
   ```
   Принимает строку-поток с данными и имя файла, в который хотим сохранить эти данные.
6. Основной файл.

   Используется для запуска всех остальных функций.

   Содержит вспомогательную функцию ```void task1_all(std::string input_filename,std::string output_filename="")```, которая в зависимости от наличия второго аргумента, направляет вывод либо в консоль, либо в файл (имя файла должно содержать хотя бы 2 символа).

Структурные единицы:
1. Класс исключений ```class MyException```
  
      Необходим для более удобной работы с исклюениями. Все выбрасываемые исключения являются объектами данного класса.

2. Структура для даты ```struct Datetime```

      Поскольку во входных данных есть дата, которую надо обрабатывать, то под нее была написана структура. Инкапсуляция здесь не очень важна, поскольку структура предназначена только для хранения данных. Однако для более корректной работы самой программы, в конструктор структуры был добавлен валидатор данных. Год ограничен с 1951 до 2199. 24-часовая запись. Остальные ограничения естественны.

3. Структура для одной полной записи ```struct Transaction```

   Также имеет встроенный валидатор, и также предназначена только для хранения данных.

Используемые библиотеки:

Исключительно стандартного пространства имен. Для ввода (и корректной работы исключений): ```<iostream>,<fstream>```, для хранения данных: ```<string>,<sstream>,<vector>```, для обработки данных: ```<regex>```

## Инструкция по сборке и запуску решения
1. Установить gcc с поддержкой C++ 20 или выше
2. Установить GNU make
3. Выполнить в каталоге с решением команду make
4. Готовое приложение будет называться task1 (для windows добавляется расширение .exe).
